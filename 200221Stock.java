

	public static int profit(int[] prices){
		if (prices.length < 2) {
			return 0;
		}
		
		int profit = 0; int min =prices[0];
		
		//最基本问题的非DP递推形式写法  No.121
    //即只允许买入卖出一次，无其他附加条件
    
    //数据整体进行一次for循环，每次指针移动时，记录前半区域的最小值，并用当前元素减去前面的最小值得到一个局部最大值，
    //然后循环更新局部最大值，遍历完数组之后会得到一个全局最大值
		for (int i = 1; i < prices.length; i++) {
			int temp = prices[i]- min;
			profit = (temp > profit)?temp:profit;
			min = (min < prices[i] )?min:prices[i];
		}
    
    return profit
}

//同时这个题目还有多种变种，如可以把买卖次数推广到K，手上一次性可以拥有的股票数量推广到N，添加手续费什么的
//通用解法是对于天数i、买卖次数K、股票数量N分别使用一个维度记录，构建一个三维数组mp[i][k][n]进行动态规划



/**三维矩阵，允许买一个股票问题的推广解*************************************************************************************************/

		
    public static int profit3d(int[] prices){
		//单独列出重新整理三维通用代码解的思路
		if (prices.length < 2) {
			return 0;
		}
		
		int[][][] mp3=new int[3][2][prices.length];
		
		//便于后期答案查看中间数据（java多维数组的快速调用原理），这里维度顺序最好设置为
		//第一维K为购买次数统计；第二维0-1标记是否拥有股票；第三维i对应天数
		
		//示例代码：1-日期；2-购买次数k；3-是否有股票0-1
		
		//示例的初始化方法
		mp3[0][0][0] = 0;//第一天没有购买股票时的利润
		mp3[0][1][0] = -prices[0];//第一天购买了股票的利润
		//按照购买次数的计数，这里不应该是mp3[1][1][0] = -price[0]吗，第一个已经买进了
		//难道买入不计数卖出才计数的？？
		//而mp3[][][0]第一天所对应的所有其他的组合，这里全部初始化为最小负值了
		//这个最小负值的初始化意义何在？？直接默认初始化为0能否可行？
		//示例代码中有mp[1][0][0],mp[1][1][0],mp[2][0][0],mp[2][1][0]均为最小负数
		//
		
		
		
		//第一次运行测试，mp3[0]列的另外四个值默认设置为0看看运行结果是否正常
		//第一次试运行，mp3[0]列的值默认为0时输出结果正常，不过可能也会有特殊情况导致异常的？？

    
    
    /************************/
		
		//示例的迭代方法
		
		for (int i = 1; i < prices.length; i++) {
		mp3[0][0][i] = mp3[0][0][i-1];//这里不带任何判断的赋值有什么意义？？
		mp3[0][1][i] = Math.max(mp3[0][1][i-1],mp3[0][0][i-1]-prices[i]);
		//理论上这里有一次买入，交易次数k应该要+1才对，但是这里的次数则保持不变
		//可能是为了处理越界问题或者是保持整体符合规则而违背局部规则的一个特殊处理
		
		//第i次购买，目前手头没有股票
		//这里的迭代是符合之前的分析k次数的变化
		mp3[1][0][i] = Math.max(mp3[1][0][i-1],mp3[0][1][i-1]+prices[i]);
		
		//第1次购买，目前手头有股票
		//这里的迭代次数k保持不变？？不符合之前的分析k次数的变化
		mp3[1][1][i] = Math.max(mp3[1][1][i-1],mp3[1][0][i-1]-prices[i]);
		
		//第2次卖出手头没股票的情况，不知道为什么只设置了一个迭代情况
		//是否考虑到购买次数最大为2，而且次数为2的时候一定是手上没有股票的时候利润最大所以只设置了这一种情况
		mp3[2][0][i] = Math.max(mp3[2][0][i-1],mp3[1][1][i-1]+prices[i]);
		
		
		}
		/************************/
    
    
    int maxProfit = 0;
		for (int i = 0; i < mp3.length; i++) {//最终答案只需要从第i-1列找到最大值即可
			maxProfit = (maxProfit > mp3[i][0][prices.length-1])?maxProfit:mp3[i][0][prices.length-1];
		}
		
		
		return maxProfit;
	}
